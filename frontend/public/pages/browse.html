<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duy·ªát phim - CGV Streaming</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link rel="stylesheet" href="../css/streaming.css?v=45">
    <script src="../js/core.js?v=100"></script>
    <style>
        .browse-header {
            padding: 120px 50px 30px;
            background: linear-gradient(180deg, rgba(20,20,20,1) 0%, rgba(20,20,20,0) 100%);
        }
        .browse-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #fff;
        }
        .browse-header p {
            color: #999;
            font-size: 1.1rem;
        }
        .browse-controls {
            padding: 20px 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .filter-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .filter-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.95rem;
        }
        .filter-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
        }
        .filter-btn.active {
            background: #e50914;
            border-color: #e50914;
        }
        .sort-select {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.95rem;
        }
        .browse-content {
            padding: 20px 50px 50px;
        }
        .movies-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .load-more {
            text-align: center;
            margin-top: 40px;
        }
        .load-more button {
            background: #e50914;
            color: #fff;
            border: none;
            padding: 15px 40px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
        }
        .load-more button:hover {
            background: #f40612;
            transform: scale(1.05);
        }
        .no-results {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }
        .no-results i {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.5;
        }
        .no-results h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-left">
                <div class="logo" role="button" tabindex="0" onclick="window.location.href='/streaming.html'" onkeydown="if(event.key==='Enter'||event.key===' '){window.location.href='/streaming.html'}">
                    <i class="fas fa-film"></i>
                    <span>CGV</span> Streaming
                </div>
                <ul class="nav-menu">
                    <li><a href="streaming.html">Trang ch·ªß</a></li>
                    <li><a href="browse.html?type=movie">Phim</a></li>
                    <li><a href="browse.html?type=series">Phim b·ªô</a></li>
                    <li><a href="browse.html" class="active">Th·ªÉ lo·∫°i</a></li>
                </ul>
            </div>
            <div class="nav-right">
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="T√¨m phim, di·ªÖn vi√™n..." autocomplete="off">
                    <i class="fas fa-search"></i>
                    <div class="search-suggestions" id="searchSuggestions"></div>
                </div>
                <div class="user-menu" id="userMenu">
                    <i class="fas fa-user-circle"></i>
                    <span id="userName">ƒêƒÉng nh·∫≠p</span>
                    <div class="dropdown">
                        <a href="#" onclick="showProfile()"><i class="fas fa-user"></i> T√†i kho·∫£n</a>
                        <a href="#" onclick="showSubscription()"><i class="fas fa-crown"></i> N√¢ng c·∫•p VIP</a>
                        <a href="#" onclick="showSettings()"><i class="fas fa-cog"></i> C√†i ƒë·∫∑t</a>
                        <a href="#" onclick="logout()"><i class="fas fa-sign-out-alt"></i> ƒêƒÉng xu·∫•t</a>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Browse Header -->
    <div class="browse-header">
        <h1 id="browseTitle">Duy·ªát phim</h1>
        <p id="browseSubtitle">Kh√°m ph√° h√†ng ngh√¨n b·ªô phim ch·∫•t l∆∞·ª£ng cao</p>
    </div>

    <!-- Browse Controls -->
    <div class="browse-controls">
        <div class="filter-group" id="filterGroup">
            <button class="filter-btn active" data-filter="all">T·∫•t c·∫£</button>
            <button class="filter-btn" data-filter="movie">Phim l·∫ª</button>
            <button class="filter-btn" data-filter="series">Phim b·ªô</button>
        </div>
        <select class="sort-select" id="sortSelect">
            <option value="latest">M·ªõi nh·∫•t</option>
            <option value="trending">Th·ªãnh h√†nh</option>
            <option value="rating">ƒê√°nh gi√° cao</option>
            <option value="views">Xem nhi·ªÅu</option>
            <option value="title">T√™n A-Z</option>
        </select>
    </div>

    <!-- Browse Content -->
    <div class="browse-content">
        <div class="movies-grid" id="moviesGrid">
            <!-- Movies will be loaded here -->
        </div>
        <div class="no-results" id="noResults" style="display:none;">
            <i class="fas fa-film"></i>
            <h3>Kh√¥ng t√¨m th·∫•y phim n√†o</h3>
            <p>Th·ª≠ thay ƒë·ªïi b·ªô l·ªçc ho·∫∑c t√¨m ki·∫øm kh√°c</p>
        </div>
        <div class="load-more" id="loadMoreSection" style="display:none;">
            <button onclick="loadMoreMovies()">
                <i class="fas fa-plus-circle"></i> Xem th√™m
            </button>
        </div>
    </div>

    <script>
        let currentUser = null;
        let allMovies = [];
        let displayedMovies = [];
    let currentFilter = 'all';
    let currentSort = 'latest';
    let currentPage = 1;
    const moviesPerPage = 48; // 48 items per page across all sections
    let isTrendingContext = false; // true when filter=trending
    let isRecommendedContext = false; // true when filter=recommended
    let isTopRatedContext = false; // true when sort=rating from URL
    let isNewReleasesContext = false; // reserved; not used for type=movie anymore
    const NEW_RELEASES_DAYS = 3; // keep for potential future use

        // Initialize page
        initializePage('Browse', async () => {
            await auth.initPromise;
            
            auth.onAuthStateChange(user => {
                currentUser = user;
                renderUserMenu();
            });

            currentUser = auth.getCurrentUser();
            renderUserMenu();
            
            setupSearch();
            parseURLParams();
            loadMovies();
            setupFilters();
        });

        // Parse URL parameters
        function parseURLParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const type = urlParams.get('type');
            const filter = urlParams.get('filter');
            const genre = urlParams.get('genre');
            const genreId = urlParams.get('genre_id');
            const genreName = urlParams.get('genre_name');
            const sort = urlParams.get('sort');

            // Store genre filter globally
            window.currentGenreFilter = genre;
            window.currentGenreId = genreId;
            window.currentGenreName = genreName;
            
            // Initialize type filter (default to 'all', or from URL type)
            if (type === 'movie') {
                window.typeFilter = 'movie';
            } else if (type === 'series') {
                window.typeFilter = 'series';
            } else {
                window.typeFilter = 'all';
            }

            // Set title based on parameters
            if (filter === 'favorites') {
                document.getElementById('browseTitle').textContent = '‚ù§Ô∏è Danh s√°ch y√™u th√≠ch';
                document.getElementById('browseSubtitle').textContent = 'Nh·ªØng b·ªô phim b·∫°n ƒë√£ l∆∞u';
                currentFilter = 'favorites';
            } else if (filter === 'trending') {
                document.getElementById('browseTitle').textContent = 'üî• Trending tu·∫ßn n√†y';
                document.getElementById('browseSubtitle').textContent = 'Phim ƒë∆∞·ª£c xem nhi·ªÅu nh·∫•t';
                currentFilter = 'all';
                currentSort = 'views'; // Use 'views' to match streaming.js
                isTrendingContext = true;
            } else if (filter === 'recommended') {
                document.getElementById('browseTitle').textContent = '‚≠ê ƒê·ªÅ xu·∫•t cho b·∫°n';
                document.getElementById('browseSubtitle').textContent = 'Phim c√≥ ƒë√°nh gi√° cao';
                currentFilter = 'all';
                currentSort = 'rating';
                isRecommendedContext = true;
            } else if (type === 'movie') {
                document.getElementById('browseTitle').textContent = 'üé¨ Phim l·∫ª';
                document.getElementById('browseSubtitle').textContent = 'T·ªïng h·ª£p phim l·∫ª';
                currentFilter = 'all';
                window.typeFilter = 'movie';
                isNewReleasesContext = false;
                const fg = document.getElementById('filterGroup');
                if (fg) fg.style.display = 'none';
            } else if (type === 'series') {
                document.getElementById('browseTitle').textContent = 'üì∫ Phim b·ªô';
                document.getElementById('browseSubtitle').textContent = 'Theo d√µi c√°c series phim h·∫•p d·∫´n';
                currentFilter = 'all';
                window.typeFilter = 'series';
                const fg = document.getElementById('filterGroup');
                if (fg) fg.style.display = 'none';
            } else if (genreId && genreName) {
                // New: Filter by genre ID using new API
                document.getElementById('browseTitle').textContent = `üé≠ ${decodeURIComponent(genreName)}`;
                document.getElementById('browseSubtitle').textContent = `Kh√°m ph√° c√°c b·ªô phim ${decodeURIComponent(genreName)}`;
                currentFilter = 'genre_id';
            } else if (genre) {
                // Map genre slug to Vietnamese display name
                const genreNames = {
                    'hanh-dong': 'üí• Phim h√†nh ƒë·ªông',
                    'hai-huoc': 'üòÇ Phim h√†i h∆∞·ªõc',
                    'tam-ly': 'üé≠ Phim t√¢m l√Ω',
                    'kinh-di': 'üëª Phim kinh d·ªã',
                    'tinh-cam': 'üíï Phim t√¨nh c·∫£m',
                    'hinh-su': 'üïµÔ∏è Phim h√¨nh s·ª±',
                    'vien-tuong': 'üöÄ Phim vi·ªÖn t∆∞·ªüng',
                    'than-thoai': 'üßô Phim th·∫ßn tho·∫°i',
                    // fallback for old slugs
                    'action': 'üí• Phim h√†nh ƒë·ªông',
                    'comedy': 'üòÇ Phim h√†i',
                    'drama': 'üé≠ Phim t√¢m l√Ω',
                    'horror': 'üëª Phim kinh d·ªã',
                    'romance': 'üíï Phim t√¨nh c·∫£m',
                    'crime': 'ÔøΩÔ∏è Phim h√¨nh s·ª±',
                    'sci-fi': 'üöÄ Phim vi·ªÖn t∆∞·ªüng',
                    'fantasy': 'üßô Phim th·∫ßn tho·∫°i'
                };
                document.getElementById('browseTitle').textContent = genreNames[genre] || `üé≠ ${genre}`;
                document.getElementById('browseSubtitle').textContent = `Kh√°m ph√° c√°c b·ªô phim ${genreNames[genre] ? genreNames[genre].replace(/^[^ ]+ /, '') : genre}`;
                currentFilter = 'genre';
            }

            if (sort) {
                currentSort = sort;
                document.getElementById('sortSelect').value = sort;
                // Check if coming from "Top Rated" link
                if (sort === 'rating') {
                    isTopRatedContext = true;
                }
            }
            
            // Set sort select value if filter is trending or recommended
            if (filter === 'trending') {
                document.getElementById('sortSelect').value = 'views';
            } else if (filter === 'recommended') {
                document.getElementById('sortSelect').value = 'rating';
            }

            // Update active filter button based on typeFilter (only if filter group is visible)
            const fg = document.getElementById('filterGroup');
            if (fg && fg.style.display !== 'none') {
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.filter === (window.typeFilter || 'all')) {
                        btn.classList.add('active');
                    }
                });
            }
        }

        // Setup filters
        function setupFilters() {
            // Filter buttons always control typeFilter
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    window.typeFilter = btn.dataset.filter; // 'all' | 'movie' | 'series'
                    currentPage = 1;
                    filterAndDisplayMovies();
                });
            });

            // Sort select
            document.getElementById('sortSelect').addEventListener('change', (e) => {
                currentSort = e.target.value;
                currentPage = 1;
                filterAndDisplayMovies();
            });
        }

        // Load movies from API
        async function loadMovies() {
            try {
                // NEW: If filtering by genre_id, use the new API endpoint
                if (currentFilter === 'genre_id' && window.currentGenreId) {
                    const res = await api.get(`/api/genres/${window.currentGenreId}/movies`, { 
                        page: 1,
                        per_page: 1000 
                    });
                    if (res && res.success) {
                        allMovies = res.data || [];
                        filterAndDisplayMovies();
                    } else {
                        showNoResults();
                    }
                    return;
                }
                
                // Load with same params as streaming.js for consistency
                const res = await api.get('/api/movies', { per_page: 100 });
                if (res && res.success) {
                    allMovies = res.data || [];
                    
                    // If favorites filter, load user favorites
                    if (currentFilter === 'favorites' && currentUser) {
                        await loadFavorites();
                    } else {
                        filterAndDisplayMovies();
                    }
                }
            } catch (err) {
                console.error('Failed to load movies:', err);
                showNoResults();
            }
        }

        // Load user favorites
        async function loadFavorites() {
            try {
                const res = await api.get(AppConfig.api.endpoints.favorites);
                if (res && res.success && res.data) {
                    const favoriteIds = res.data.map(f => f.movie_id || f.id);
                    allMovies = allMovies.filter(m => favoriteIds.includes(m.id));
                    filterAndDisplayMovies();
                } else {
                    showNoResults();
                }
            } catch (err) {
                console.error('Failed to load favorites:', err);
                showNoResults();
            }
        }

        // Filter and display movies
        function filterAndDisplayMovies() {
            let filtered = [...allMovies];

            // STEP 1: Apply context filters first
            // Genre filter (support both TEXT field and array)
            if (window.currentGenreFilter) {
                filtered = filtered.filter(m => {
                    const genresData = m.genres || m.category || '';
                    const filterGenre = window.currentGenreFilter.toLowerCase();
                    
                    // Helper function to check genre match
                    const hasGenre = (genreNames) => {
                        if (typeof genresData === 'string') {
                            const lowerText = genresData.toLowerCase();
                            return genreNames.some(name => lowerText.includes(name.toLowerCase()));
                        }
                        if (Array.isArray(genresData)) {
                            return genresData.some(g => {
                                const genreName = (typeof g === 'string' ? g : g.name || '').toLowerCase();
                                return genreNames.some(name => genreName.includes(name.toLowerCase()));
                            });
                        }
                        return false;
                    };
                    
                    // Vietnamese slug support
                    if (filterGenre === 'hanh-dong') return hasGenre(['h√†nh ƒë·ªông', 'hanh-dong', 'action']);
                    if (filterGenre === 'hai-huoc') return hasGenre(['h√†i h∆∞·ªõc', 'hai-huoc', 'comedy', 'h√†i']);
                    if (filterGenre === 'tam-ly') return hasGenre(['t√¢m l√Ω', 'tam-ly', 'drama']);
                    if (filterGenre === 'kinh-di') return hasGenre(['kinh d·ªã', 'kinh-di', 'horror']);
                    if (filterGenre === 'tinh-cam') return hasGenre(['t√¨nh c·∫£m', 'tinh-cam', 'romance', 'l√£ng m·∫°n']);
                    if (filterGenre === 'hinh-su') return hasGenre(['h√¨nh s·ª±', 'hinh-su', 'crime', 't·ªôi ph·∫°m']);
                    if (filterGenre === 'vien-tuong') return hasGenre(['vi·ªÖn t∆∞·ªüng', 'vien-tuong', 'sci-fi', 'khoa h·ªçc vi·ªÖn t∆∞·ªüng']);
                    if (filterGenre === 'than-thoai') return hasGenre(['th·∫ßn tho·∫°i', 'than-thoai', 'fantasy', 'gi·∫£ t∆∞·ªüng']);
                    // fallback for old slugs
                    if (filterGenre === 'action') return hasGenre(['action', 'h√†nh ƒë·ªông']);
                    if (filterGenre === 'comedy') return hasGenre(['comedy', 'h√†i', 'h√†i h∆∞·ªõc']);
                    if (filterGenre === 'drama') return hasGenre(['drama', 't√¢m l√Ω']);
                    if (filterGenre === 'horror') return hasGenre(['horror', 'kinh d·ªã']);
                    if (filterGenre === 'romance') return hasGenre(['romance', 't√¨nh c·∫£m']);
                    if (filterGenre === 'crime') return hasGenre(['crime', 'h√¨nh s·ª±']);
                    if (filterGenre === 'sci-fi') return hasGenre(['sci-fi', 'vi·ªÖn t∆∞·ªüng']);
                    if (filterGenre === 'fantasy') return hasGenre(['fantasy', 'th·∫ßn tho·∫°i']);
                    
                    // Generic fallback
                    return hasGenre([filterGenre]);
                });
            }

            // New releases date filter (for type=movie context, last 30 days)
            if (isNewReleasesContext) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - NEW_RELEASES_DAYS);
                filtered = filtered.filter(m => {
                    const movieDate = new Date(m.created_at || m.release_date || m.updated_at);
                    return movieDate >= cutoffDate;
                });
            }

            // STEP 2: Apply type filter universally
            const typeFilter = window.typeFilter || 'all';
            if (typeFilter === 'movie') {
                filtered = filtered.filter(m => m.type === 'movie');
            } else if (typeFilter === 'series') {
                filtered = filtered.filter(m => m.type === 'series');
            }

            // Apply recommended filter (IMDb >= 7.0)
            if (isRecommendedContext || currentSort === 'rating') {
                filtered = filtered.filter(m => {
                    const rating = parseFloat(m.imdb_rating || m.rating || 0);
                    return rating >= 7.0;
                });
            }

            // Sort movies
            filtered.sort((a, b) => {
                switch (currentSort) {
                    case 'latest':
                        return new Date(b.created_at || b.release_date) - new Date(a.created_at || a.release_date);
                    case 'trending':
                        return (b.views || 0) - (a.views || 0);
                    case 'rating':
                        return (parseFloat(b.imdb_rating || b.rating || 0)) - (parseFloat(a.imdb_rating || a.rating || 0));
                    case 'views':
                        return (b.views || 0) - (a.views || 0);
                    case 'title':
                        return (a.title || '').localeCompare(b.title || '');
                    default:
                        return 0;
                }
            });

            // No total caps; pagination (48 per page) controls visible count

            displayedMovies = filtered;
            currentPage = 1;
            renderMovies();
        }

        // Render movies
        function renderMovies() {
            const grid = document.getElementById('moviesGrid');
            const noResults = document.getElementById('noResults');
            const loadMoreSection = document.getElementById('loadMoreSection');

            if (displayedMovies.length === 0) {
                showNoResults();
                return;
            }

            noResults.style.display = 'none';
            grid.innerHTML = '';

            const endIndex = currentPage * moviesPerPage;
            const moviesToShow = displayedMovies.slice(0, endIndex);

            moviesToShow.forEach(movie => {
                const card = buildMovieCard(movie);
                grid.appendChild(card);
            });

            // Show/hide load more button
            if (endIndex < displayedMovies.length) {
                loadMoreSection.style.display = 'block';
            } else {
                loadMoreSection.style.display = 'none';
            }
        }

        // Load more movies
        function loadMoreMovies() {
            currentPage++;
            renderMovies();
            window.scrollTo({
                top: document.getElementById('moviesGrid').offsetTop - 100,
                behavior: 'smooth'
            });
        }

        // Show no results message
        function showNoResults() {
            document.getElementById('moviesGrid').innerHTML = '';
            document.getElementById('noResults').style.display = 'block';
            document.getElementById('loadMoreSection').style.display = 'none';
        }

        // Build movie card (reuse from streaming.js)
        function buildMovieCard(item) {
            const card = document.createElement('div');
            card.className = 'movie-card';
            card.onclick = () => {
                window.location.href = `movie-detail.html?id=${item.id}`;
            };

            const poster = item.poster_url || item.thumb_url || 'https://via.placeholder.com/300x450?text=No+Image';
            
            card.innerHTML = `
                <div class="movie-poster">
                    <img src="${poster}" alt="${item.title || item.name}" loading="lazy"
                         onerror="this.src='https://via.placeholder.com/300x450?text=No+Image'">
                    <div class="movie-overlay">
                        <div class="play-btn">
                            <i class="fas fa-play"></i>
                        </div>
                        <div class="movie-info-overlay">
                            <h4>${item.title || item.name}</h4>
                            <div class="movie-meta">
                                <span class="rating"><i class="fas fa-star"></i> ${item.imdb_rating || item.rating || 'N/A'}</span>
                                <span class="year">${item.year || new Date(item.release_date).getFullYear() || 'N/A'}</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="movie-title">${item.title || item.name}</div>
            `;

            // Add episode badge for series
            if (item.type === 'series' && item.total_episodes) {
                const badge = document.createElement('div');
                badge.className = 'status-badge';
                badge.innerHTML = `<i class="fas fa-list"></i> ${item.current_episode || 1}/${item.total_episodes} t·∫≠p`;
                card.querySelector('.movie-poster').appendChild(badge);
            }

            return card;
        }

        // Render user menu
        function renderUserMenu() {
            const userMenu = document.getElementById('userMenu');
            const userName = document.getElementById('userName');
            
            if (currentUser) {
                userName.textContent = currentUser.email.split('@')[0];
                userMenu.classList.add('logged-in');
            } else {
                userName.textContent = 'ƒêƒÉng nh·∫≠p';
                userMenu.classList.remove('logged-in');
                userMenu.onclick = () => {
                    window.location.href = 'login.html';
                };
            }
        }

        // Setup search
        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchSuggestions = document.getElementById('searchSuggestions');

            searchInput.addEventListener('input', async (e) => {
                const query = e.target.value.trim();
                
                if (query.length < 2) {
                    searchSuggestions.style.display = 'none';
                    return;
                }

                const results = allMovies.filter(m => 
                    (m.title || m.name || '').toLowerCase().includes(query.toLowerCase()) ||
                    (m.actors || []).some(a => a.toLowerCase().includes(query.toLowerCase()))
                ).slice(0, 5);

                if (results.length > 0) {
                    searchSuggestions.innerHTML = results.map(m => `
                        <div class="suggestion-item" onclick="window.location.href='movie-detail.html?id=${m.id}'">
                            <img src="${m.poster_url || m.thumb_url}" alt="${m.title || m.name}">
                            <div class="suggestion-info">
                                <div class="suggestion-title">${m.title || m.name}</div>
                                <div class="suggestion-meta">${m.year || ''} ‚Ä¢ ${m.type === 'series' ? 'Phim b·ªô' : 'Phim l·∫ª'}</div>
                            </div>
                        </div>
                    `).join('');
                    searchSuggestions.style.display = 'block';
                } else {
                    searchSuggestions.style.display = 'none';
                }
            });

            // Close suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if (!searchInput.contains(e.target) && !searchSuggestions.contains(e.target)) {
                    searchSuggestions.style.display = 'none';
                }
            });

            // Handle Enter key
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const query = e.target.value.trim();
                    if (query) {
                        // Filter movies by search query
                        displayedMovies = allMovies.filter(m => 
                            (m.title || m.name || '').toLowerCase().includes(query.toLowerCase()) ||
                            (m.actors || []).some(a => a.toLowerCase().includes(query.toLowerCase()))
                        );
                        currentPage = 1;
                        renderMovies();
                        searchSuggestions.style.display = 'none';
                    }
                }
            });
        }

        // Profile, Settings, Subscription handlers
        function showProfile() {
            window.location.href = 'profile.html';
        }

        function showSettings() {
            window.location.href = 'settings.html';
        }

        function showSubscription() {
            window.location.href = 'subscription.html';
        }

        function logout() {
            auth.logout();
            window.location.href = 'login.html';
        }
    </script>
</body>
</html>
